{"ast":null,"code":"export function createGrid(rows, columns) {\n  let grid = [];\n  let i = 0;\n\n  while (i < rows) {\n    grid.push(Array(columns).fill(null));\n    i++;\n  }\n\n  grid.push(Array(columns).fill(\"base\"));\n  return grid;\n}\nexport function checkResult(grid) {\n  if (!grid) return;\n  const tie = grid.every(row => !row.includes(null));\n  if (tie) return \"Draw!\";\n\n  for (let x in grid) {\n    x = parseInt(x);\n\n    for (let y in grid[x]) {\n      y = parseInt(y);\n      let value = grid[x][y];\n      if (value === \"base\") continue;\n\n      if ( //left and right\n      value && value === grid[x][y + 1] && value === grid[x][y + 2] && value === grid[x][y + 3] || //up and down\n      value && value === grid[x + 1][y] && value === grid[x + 2][y] && value === grid[x + 3][y] || //diagonal - left to right (\\)\n      value && value === grid[x + 1][y + 1] && value === grid[x + 2][y + 2] && value === grid[x + 3][y + 3] || //diagonal - right to left (/)\n      value && value === grid[x + 1][y - 1] && value === grid[x + 2][y - 2] && value === grid[x + 3][y - 3]) {\n        return value + \" wins\";\n      }\n    }\n  }\n}\nexport function placeAValidMove(grid, player, rowIndex, columnIndex) {\n  let r = rowIndex;\n  let c = columnIndex;\n\n  if (grid[r + 1][c] !== null && grid[r][c] === null) {\n    let newGrid = grid.slice();\n    newGrid[r][c] = player;\n    return newGrid;\n  }\n\n  return;\n}\nexport function findAiMove(grid, player) {\n  let bestMoveScore = 100;\n  let move;\n\n  for (let rowIndex in grid) {\n    rowIndex = parseInt(rowIndex);\n\n    for (let columnIndex in grid[rowIndex]) {\n      columnIndex = parseInt(rowIndex);\n      let newGrid = placeAValidMove(grid, player, rowIndex, columnIndex);\n      console.log(grid[rowIndex]);\n      console.log(grid[rowIndex][columnIndex]);\n\n      if (newGrid) {\n        console.log({\n          newGrid\n        });\n        const moveScore = maxScore(newGrid, player);\n\n        if (moveScore < bestMoveScore) {\n          bestMoveScore = moveScore;\n          move = [rowIndex, columnIndex];\n        }\n      }\n    }\n  }\n\n  return move;\n} // export function minScore(grid, player) {\n//   let result = checkResult(grid);\n//   if (result.includes(\"Player-1\")) return 10;\n//   if (result.includes(\"Player-2\")) return -10;\n//   if (result.includes(\"Draw\")) return 0;\n//   let bestMoveScore = 100;\n//   let move;\n//   for (let rowIndex in grid) {\n// rowIndex = parseInt(rowIndex)\n//     for (let columnIndex in grid[rowIndex]) {\n// columnIndex = parseInt(rowIndex)\n//       let newGrid = placeAValidMove(grid, player, rowIndex, columnIndex);\n//       if (newGrid) {\n//         const moveScore = maxScore(newGrid, player);\n//         if (moveScore < bestMoveScore) {\n//           bestMoveScore = moveScore;\n//           move = [rowIndex, columnIndex];\n//         }\n//       }\n//     }\n//   }\n//   return bestMoveScore;\n// }\n// export function maxScore(grid, player) {\n//   let result = checkResult(grid);\n//   if (result.includes(\"Player-1\")) return 10;\n//   if (result.includes(\"Player-2\")) return -10;\n//   if (result.includes(\"Draw\")) return 0;\n//   let bestMoveScore = -100;\n//   let move;\n//   for (let rowIndex in grid) {\n// rowIndex = parseInt(rowIndex)\n//     for (let columnIndex in grid[rowIndex]) {\n// columnIndex = parseInt(rowIndex)\n//       let newGrid = placeAValidMove(grid, player, rowIndex, columnIndex);\n//       if (newGrid) {\n//         const moveScore = minScore(newGrid, player);\n//         if (moveScore > bestMoveScore) {\n//           bestMoveScore = moveScore;\n//           move = [rowIndex, columnIndex];\n//         }\n//       }\n//     }\n//   }\n//   return bestMoveScore;\n// }","map":{"version":3,"sources":["/Users/paulinez/connect-four/client/src/components/Game/help.js"],"names":["createGrid","rows","columns","grid","i","push","Array","fill","checkResult","tie","every","row","includes","x","parseInt","y","value","placeAValidMove","player","rowIndex","columnIndex","r","c","newGrid","slice","findAiMove","bestMoveScore","move","console","log","moveScore","maxScore"],"mappings":"AAAA,OAAO,SAASA,UAAT,CAAoBC,IAApB,EAA0BC,OAA1B,EAAmC;AACxC,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIC,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGH,IAAX,EAAiB;AACfE,IAAAA,IAAI,CAACE,IAAL,CAAUC,KAAK,CAACJ,OAAD,CAAL,CAAeK,IAAf,CAAoB,IAApB,CAAV;AACAH,IAAAA,CAAC;AACF;;AACDD,EAAAA,IAAI,CAACE,IAAL,CAAUC,KAAK,CAACJ,OAAD,CAAL,CAAeK,IAAf,CAAoB,MAApB,CAAV;AACA,SAAOJ,IAAP;AACD;AAED,OAAO,SAASK,WAAT,CAAqBL,IAArB,EAA2B;AAChC,MAAI,CAACA,IAAL,EAAW;AACX,QAAMM,GAAG,GAAGN,IAAI,CAACO,KAAL,CAAYC,GAAD,IAAS,CAACA,GAAG,CAACC,QAAJ,CAAa,IAAb,CAArB,CAAZ;AACA,MAAIH,GAAJ,EAAS,OAAO,OAAP;;AAET,OAAK,IAAII,CAAT,IAAcV,IAAd,EAAoB;AAClBU,IAAAA,CAAC,GAAGC,QAAQ,CAACD,CAAD,CAAZ;;AACA,SAAK,IAAIE,CAAT,IAAcZ,IAAI,CAACU,CAAD,CAAlB,EAAuB;AACrBE,MAAAA,CAAC,GAAGD,QAAQ,CAACC,CAAD,CAAZ;AACA,UAAIC,KAAK,GAAGb,IAAI,CAACU,CAAD,CAAJ,CAAQE,CAAR,CAAZ;AAEA,UAAIC,KAAK,KAAK,MAAd,EAAsB;;AACtB,WACE;AACCA,MAAAA,KAAK,IACJA,KAAK,KAAKb,IAAI,CAACU,CAAD,CAAJ,CAAQE,CAAC,GAAG,CAAZ,CADX,IAECC,KAAK,KAAKb,IAAI,CAACU,CAAD,CAAJ,CAAQE,CAAC,GAAG,CAAZ,CAFX,IAGCC,KAAK,KAAKb,IAAI,CAACU,CAAD,CAAJ,CAAQE,CAAC,GAAG,CAAZ,CAHZ,IAIA;AACCC,MAAAA,KAAK,IACJA,KAAK,KAAKb,IAAI,CAACU,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAZ,CADX,IAECC,KAAK,KAAKb,IAAI,CAACU,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAZ,CAFX,IAGCC,KAAK,KAAKb,IAAI,CAACU,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAZ,CARZ,IASA;AACCC,MAAAA,KAAK,IACJA,KAAK,KAAKb,IAAI,CAACU,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAC,GAAG,CAAhB,CADX,IAECC,KAAK,KAAKb,IAAI,CAACU,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAC,GAAG,CAAhB,CAFX,IAGCC,KAAK,KAAKb,IAAI,CAACU,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAC,GAAG,CAAhB,CAbZ,IAcA;AACCC,MAAAA,KAAK,IACJA,KAAK,KAAKb,IAAI,CAACU,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAC,GAAG,CAAhB,CADX,IAECC,KAAK,KAAKb,IAAI,CAACU,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAC,GAAG,CAAhB,CAFX,IAGCC,KAAK,KAAKb,IAAI,CAACU,CAAC,GAAG,CAAL,CAAJ,CAAYE,CAAC,GAAG,CAAhB,CApBd,EAqBE;AACA,eAAOC,KAAK,GAAG,OAAf;AACD;AACF;AACF;AACF;AAED,OAAO,SAASC,eAAT,CAAyBd,IAAzB,EAA+Be,MAA/B,EAAuCC,QAAvC,EAAiDC,WAAjD,EAA8D;AACnE,MAAIC,CAAC,GAAGF,QAAR;AACA,MAAIG,CAAC,GAAGF,WAAR;;AACA,MAAIjB,IAAI,CAACkB,CAAC,GAAG,CAAL,CAAJ,CAAYC,CAAZ,MAAmB,IAAnB,IAA2BnB,IAAI,CAACkB,CAAD,CAAJ,CAAQC,CAAR,MAAe,IAA9C,EAAoD;AAClD,QAAIC,OAAO,GAAGpB,IAAI,CAACqB,KAAL,EAAd;AACAD,IAAAA,OAAO,CAACF,CAAD,CAAP,CAAWC,CAAX,IAAgBJ,MAAhB;AACA,WAAOK,OAAP;AACD;;AACD;AACD;AAED,OAAO,SAASE,UAAT,CAAoBtB,IAApB,EAA0Be,MAA1B,EAAkC;AACvC,MAAIQ,aAAa,GAAG,GAApB;AACA,MAAIC,IAAJ;;AACA,OAAK,IAAIR,QAAT,IAAqBhB,IAArB,EAA2B;AACzBgB,IAAAA,QAAQ,GAAGL,QAAQ,CAACK,QAAD,CAAnB;;AACA,SAAK,IAAIC,WAAT,IAAwBjB,IAAI,CAACgB,QAAD,CAA5B,EAAwC;AACtCC,MAAAA,WAAW,GAAGN,QAAQ,CAACK,QAAD,CAAtB;AACA,UAAII,OAAO,GAAGN,eAAe,CAACd,IAAD,EAAOe,MAAP,EAAeC,QAAf,EAAyBC,WAAzB,CAA7B;AACAQ,MAAAA,OAAO,CAACC,GAAR,CAAY1B,IAAI,CAACgB,QAAD,CAAhB;AACAS,MAAAA,OAAO,CAACC,GAAR,CAAY1B,IAAI,CAACgB,QAAD,CAAJ,CAAeC,WAAf,CAAZ;;AAEA,UAAIG,OAAJ,EAAa;AACXK,QAAAA,OAAO,CAACC,GAAR,CAAY;AAAEN,UAAAA;AAAF,SAAZ;AAEA,cAAMO,SAAS,GAAGC,QAAQ,CAACR,OAAD,EAAUL,MAAV,CAA1B;;AACA,YAAIY,SAAS,GAAGJ,aAAhB,EAA+B;AAC7BA,UAAAA,aAAa,GAAGI,SAAhB;AACAH,UAAAA,IAAI,GAAG,CAACR,QAAD,EAAWC,WAAX,CAAP;AACD;AACF;AACF;AACF;;AACD,SAAOO,IAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["export function createGrid(rows, columns) {\n  let grid = [];\n  let i = 0;\n  while (i < rows) {\n    grid.push(Array(columns).fill(null));\n    i++;\n  }\n  grid.push(Array(columns).fill(\"base\"));\n  return grid;\n}\n\nexport function checkResult(grid) {\n  if (!grid) return;\n  const tie = grid.every((row) => !row.includes(null));\n  if (tie) return \"Draw!\";\n\n  for (let x in grid) {\n    x = parseInt(x);\n    for (let y in grid[x]) {\n      y = parseInt(y);\n      let value = grid[x][y];\n\n      if (value === \"base\") continue;\n      if (\n        //left and right\n        (value &&\n          value === grid[x][y + 1] &&\n          value === grid[x][y + 2] &&\n          value === grid[x][y + 3]) ||\n        //up and down\n        (value &&\n          value === grid[x + 1][y] &&\n          value === grid[x + 2][y] &&\n          value === grid[x + 3][y]) ||\n        //diagonal - left to right (\\)\n        (value &&\n          value === grid[x + 1][y + 1] &&\n          value === grid[x + 2][y + 2] &&\n          value === grid[x + 3][y + 3]) ||\n        //diagonal - right to left (/)\n        (value &&\n          value === grid[x + 1][y - 1] &&\n          value === grid[x + 2][y - 2] &&\n          value === grid[x + 3][y - 3])\n      ) {\n        return value + \" wins\";\n      }\n    }\n  }\n}\n\nexport function placeAValidMove(grid, player, rowIndex, columnIndex) {\n  let r = rowIndex;\n  let c = columnIndex;\n  if (grid[r + 1][c] !== null && grid[r][c] === null) {\n    let newGrid = grid.slice();\n    newGrid[r][c] = player;\n    return newGrid;\n  }\n  return;\n}\n\nexport function findAiMove(grid, player) {\n  let bestMoveScore = 100;\n  let move;\n  for (let rowIndex in grid) {\n    rowIndex = parseInt(rowIndex);\n    for (let columnIndex in grid[rowIndex]) {\n      columnIndex = parseInt(rowIndex);\n      let newGrid = placeAValidMove(grid, player, rowIndex, columnIndex);\n      console.log(grid[rowIndex]);\n      console.log(grid[rowIndex][columnIndex]);\n\n      if (newGrid) {\n        console.log({ newGrid });\n\n        const moveScore = maxScore(newGrid, player);\n        if (moveScore < bestMoveScore) {\n          bestMoveScore = moveScore;\n          move = [rowIndex, columnIndex];\n        }\n      }\n    }\n  }\n  return move;\n}\n\n// export function minScore(grid, player) {\n//   let result = checkResult(grid);\n//   if (result.includes(\"Player-1\")) return 10;\n//   if (result.includes(\"Player-2\")) return -10;\n//   if (result.includes(\"Draw\")) return 0;\n//   let bestMoveScore = 100;\n//   let move;\n//   for (let rowIndex in grid) {\n// rowIndex = parseInt(rowIndex)\n\n//     for (let columnIndex in grid[rowIndex]) {\n// columnIndex = parseInt(rowIndex)\n\n//       let newGrid = placeAValidMove(grid, player, rowIndex, columnIndex);\n//       if (newGrid) {\n//         const moveScore = maxScore(newGrid, player);\n//         if (moveScore < bestMoveScore) {\n//           bestMoveScore = moveScore;\n//           move = [rowIndex, columnIndex];\n//         }\n//       }\n//     }\n//   }\n//   return bestMoveScore;\n// }\n\n// export function maxScore(grid, player) {\n//   let result = checkResult(grid);\n//   if (result.includes(\"Player-1\")) return 10;\n//   if (result.includes(\"Player-2\")) return -10;\n//   if (result.includes(\"Draw\")) return 0;\n//   let bestMoveScore = -100;\n//   let move;\n//   for (let rowIndex in grid) {\n// rowIndex = parseInt(rowIndex)\n\n//     for (let columnIndex in grid[rowIndex]) {\n// columnIndex = parseInt(rowIndex)\n\n//       let newGrid = placeAValidMove(grid, player, rowIndex, columnIndex);\n//       if (newGrid) {\n//         const moveScore = minScore(newGrid, player);\n//         if (moveScore > bestMoveScore) {\n//           bestMoveScore = moveScore;\n//           move = [rowIndex, columnIndex];\n//         }\n//       }\n//     }\n//   }\n//   return bestMoveScore;\n// }\n"]},"metadata":{},"sourceType":"module"}