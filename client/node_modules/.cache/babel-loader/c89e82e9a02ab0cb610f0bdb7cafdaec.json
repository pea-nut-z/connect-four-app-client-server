{"ast":null,"code":"// NOTE\n// r = row index\n// c = column index\n// Last row of grid has values of \"base\".\n// When doing a loop, the last row will be skipped.\nexport function createGrid(r, c) {\n  let grid = [];\n  let i = 0;\n\n  while (i < r) {\n    // if (i === r - 1) {\n    //   grid.push(Array(c).fill(\"base\"));\n    // } else {\n    //   grid.push(Array(c).fill(null));\n    // }\n    // i++;\n    grid.push(Array(c).fill(\"null\"));\n    i++;\n  } // grid.push(Array(c).fill(\"base\"));\n\n\n  return grid;\n}\nexport function checkResult(grid) {\n  const tie = grid.every(row => !row.includes(null));\n  if (tie) return \"Draw!\";\n\n  for (let r = 0; r < grid.length - 1; r++) {\n    for (let c = 0; c < grid[r].length; c++) {\n      let value = grid[r][c];\n\n      if ( //left and right\n      value && value === grid[r][c + 1] && value === grid[r][c + 2] && value === grid[r][c + 3] || //up and down\n      value && value === grid[r + 1][c] && value === grid[r + 2][c] && value === grid[r + 3][c] || //diagonal \" \\ \"\n      value && value === grid[r + 1][c + 1] && value === grid[r + 2][c + 2] && value === grid[r + 3][c + 3] || //diagonal \" / \"\n      value && value === grid[r + 1][c - 1] && value === grid[r + 2][c - 2] && value === grid[r + 3][c - 3]) {\n        return value + \" wins\";\n      }\n    }\n  }\n\n  return null;\n}\nexport function findAValidMove(grid, player, c) {\n  // if (\n  //   (grid[r + 1][c] !== null && grid[r][c] === null) ||\n  //   (grid[r + 1][c] === undefined && grid[r][c] === \"base\")\n  // ) {\n  //   grid[r][c] = player;\n  //   return grid;\n  // }\n  let r = grid.length - 1;\n\n  while (r >= 0) {\n    console.log({\n      r\n    });\n    console.log({\n      c\n    });\n\n    if (grid[r][c] === null) {\n      console.log(\"found\");\n      grid[r][c] = player;\n      break;\n    }\n\n    r--;\n  }\n}\nexport function findAiMove(grid, huPlayer, aiPlayer) {\n  let MAX_DEPTH = 5;\n  let bestMoveScore = 100;\n  let move = [];\n\n  for (let r = grid.length - 2; r > 0; r--) {\n    for (let c = grid[r].length - 1; c > 0; c--) {\n      const newGrid = findAValidMove(grid, aiPlayer, r, c);\n\n      if (newGrid) {\n        const moveScore = maxScore(grid, MAX_DEPTH, huPlayer, aiPlayer);\n        grid[r][c] = null;\n\n        if (moveScore < bestMoveScore) {\n          bestMoveScore = moveScore;\n          move = [r, c];\n        }\n      }\n    }\n  }\n\n  console.log(\"found move\");\n  return move;\n}\n\nfunction minScore(grid, depth, huPlayer, aiPlayer) {\n  let result = checkResult(grid);\n\n  if (result) {\n    console.log(\"result\");\n    if (result === \"Player-1 wins\") return 10;\n    if (result === \"Player-2 wins\") return -10;\n    if (result === \"Draw\") return 0;\n  }\n\n  if (depth === 0) return 0;\n  let bestMoveScore = 100;\n\n  for (let r = grid.length - 2; r > 0; r--) {\n    for (let c = grid[r].length - 1; c > 0; c--) {\n      const newGrid = findAValidMove(grid, aiPlayer, r, c);\n\n      if (newGrid) {\n        const moveScore = maxScore(grid, depth - 1, huPlayer, aiPlayer);\n        grid[r][c] = null;\n\n        if (moveScore < bestMoveScore) {\n          bestMoveScore = moveScore;\n        }\n      }\n    }\n  }\n\n  return bestMoveScore;\n}\n\nfunction maxScore(grid, depth, huPlayer, aiPlayer) {\n  let result = checkResult(grid);\n\n  if (result) {\n    console.log(\"result\");\n    if (result === \"Player-1 wins\") return 10;\n    if (result === \"Player-2 wins\") return -10;\n    if (result === \"Draw\") return 0;\n  }\n\n  if (depth === 0) return 0;\n  let bestMoveScore = -100;\n\n  for (let r = grid.length - 2; r > 0; r--) {\n    for (let c = grid[r].length - 1; c > 0; c--) {\n      const newGrid = findAValidMove(grid, huPlayer, r, c);\n\n      if (newGrid) {\n        const moveScore = minScore(grid, depth - 1, huPlayer, aiPlayer);\n        grid[r][c] = null;\n\n        if (moveScore > bestMoveScore) {\n          bestMoveScore = moveScore;\n        }\n      }\n    }\n  }\n\n  return bestMoveScore;\n}","map":{"version":3,"sources":["/Users/paulinez/connect-four/client/src/components/Game/help.js"],"names":["createGrid","r","c","grid","i","push","Array","fill","checkResult","tie","every","row","includes","length","value","findAValidMove","player","console","log","findAiMove","huPlayer","aiPlayer","MAX_DEPTH","bestMoveScore","move","newGrid","moveScore","maxScore","minScore","depth","result"],"mappings":"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","sourcesContent":["// NOTE\n// r = row index\n// c = column index\n// Last row of grid has values of \"base\".\n// When doing a loop, the last row will be skipped.\n\nexport function createGrid(r, c) {\n  let grid = [];\n  let i = 0;\n  while (i < r) {\n    // if (i === r - 1) {\n    //   grid.push(Array(c).fill(\"base\"));\n    // } else {\n    //   grid.push(Array(c).fill(null));\n    // }\n    // i++;\n    grid.push(Array(c).fill(\"null\"));\n    i++;\n  }\n  // grid.push(Array(c).fill(\"base\"));\n  return grid;\n}\n\nexport function checkResult(grid) {\n  const tie = grid.every((row) => !row.includes(null));\n  if (tie) return \"Draw!\";\n\n  for (let r = 0; r < grid.length - 1; r++) {\n    for (let c = 0; c < grid[r].length; c++) {\n      let value = grid[r][c];\n\n      if (\n        //left and right\n        (value &&\n          value === grid[r][c + 1] &&\n          value === grid[r][c + 2] &&\n          value === grid[r][c + 3]) ||\n        //up and down\n        (value &&\n          value === grid[r + 1][c] &&\n          value === grid[r + 2][c] &&\n          value === grid[r + 3][c]) ||\n        //diagonal \" \\ \"\n        (value &&\n          value === grid[r + 1][c + 1] &&\n          value === grid[r + 2][c + 2] &&\n          value === grid[r + 3][c + 3]) ||\n        //diagonal \" / \"\n        (value &&\n          value === grid[r + 1][c - 1] &&\n          value === grid[r + 2][c - 2] &&\n          value === grid[r + 3][c - 3])\n      ) {\n        return value + \" wins\";\n      }\n    }\n  }\n  return null;\n}\n\nexport function findAValidMove(grid, player, c) {\n  // if (\n  //   (grid[r + 1][c] !== null && grid[r][c] === null) ||\n  //   (grid[r + 1][c] === undefined && grid[r][c] === \"base\")\n  // ) {\n  //   grid[r][c] = player;\n  //   return grid;\n  // }\n  let r = grid.length - 1;\n  while (r >= 0) {\n    console.log({ r });\n    console.log({ c });\n\n    if (grid[r][c] === null) {\n      console.log(\"found\");\n\n      grid[r][c] = player;\n      break;\n    }\n    r--;\n  }\n}\n\nexport function findAiMove(grid, huPlayer, aiPlayer) {\n  let MAX_DEPTH = 5;\n  let bestMoveScore = 100;\n  let move = [];\n\n  for (let r = grid.length - 2; r > 0; r--) {\n    for (let c = grid[r].length - 1; c > 0; c--) {\n      const newGrid = findAValidMove(grid, aiPlayer, r, c);\n      if (newGrid) {\n        const moveScore = maxScore(grid, MAX_DEPTH, huPlayer, aiPlayer);\n        grid[r][c] = null;\n        if (moveScore < bestMoveScore) {\n          bestMoveScore = moveScore;\n          move = [r, c];\n        }\n      }\n    }\n  }\n  console.log(\"found move\");\n  return move;\n}\n\nfunction minScore(grid, depth, huPlayer, aiPlayer) {\n  let result = checkResult(grid);\n  if (result) {\n    console.log(\"result\");\n    if (result === \"Player-1 wins\") return 10;\n    if (result === \"Player-2 wins\") return -10;\n    if (result === \"Draw\") return 0;\n  }\n  if (depth === 0) return 0;\n\n  let bestMoveScore = 100;\n  for (let r = grid.length - 2; r > 0; r--) {\n    for (let c = grid[r].length - 1; c > 0; c--) {\n      const newGrid = findAValidMove(grid, aiPlayer, r, c);\n      if (newGrid) {\n        const moveScore = maxScore(grid, depth - 1, huPlayer, aiPlayer);\n        grid[r][c] = null;\n        if (moveScore < bestMoveScore) {\n          bestMoveScore = moveScore;\n        }\n      }\n    }\n  }\n  return bestMoveScore;\n}\n\nfunction maxScore(grid, depth, huPlayer, aiPlayer) {\n  let result = checkResult(grid);\n  if (result) {\n    console.log(\"result\");\n    if (result === \"Player-1 wins\") return 10;\n    if (result === \"Player-2 wins\") return -10;\n    if (result === \"Draw\") return 0;\n  }\n  if (depth === 0) return 0;\n\n  let bestMoveScore = -100;\n  for (let r = grid.length - 2; r > 0; r--) {\n    for (let c = grid[r].length - 1; c > 0; c--) {\n      const newGrid = findAValidMove(grid, huPlayer, r, c);\n      if (newGrid) {\n        const moveScore = minScore(grid, depth - 1, huPlayer, aiPlayer);\n        grid[r][c] = null;\n        if (moveScore > bestMoveScore) {\n          bestMoveScore = moveScore;\n        }\n      }\n    }\n  }\n  return bestMoveScore;\n}\n"]},"metadata":{},"sourceType":"module"}