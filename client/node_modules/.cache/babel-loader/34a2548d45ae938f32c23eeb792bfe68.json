{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Namespace = void 0;\n\nconst socket_1 = require(\"./socket\");\n\nconst events_1 = require(\"events\");\n\nconst socket_io_parser_1 = require(\"socket.io-parser\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"socket.io:namespace\");\n\nclass Namespace extends events_1.EventEmitter {\n  /**\n   * Namespace constructor.\n   *\n   * @param server instance\n   * @param name\n   */\n  constructor(server, name) {\n    super();\n    this.sockets = new Map();\n    /** @private */\n\n    this._fns = [];\n    /** @private */\n\n    this._rooms = new Set();\n    /** @private */\n\n    this._flags = {};\n    /** @private */\n\n    this._ids = 0;\n    this.server = server;\n    this.name = name;\n\n    this._initAdapter();\n  }\n  /**\n   * Initializes the `Adapter` for this nsp.\n   * Run upon changing adapter by `Server#adapter`\n   * in addition to the constructor.\n   *\n   * @private\n   */\n\n\n  _initAdapter() {\n    this.adapter = new (this.server.adapter())(this);\n  }\n  /**\n   * Sets up namespace middleware.\n   *\n   * @return self\n   * @public\n   */\n\n\n  use(fn) {\n    this._fns.push(fn);\n\n    return this;\n  }\n  /**\n   * Executes the middleware for an incoming client.\n   *\n   * @param socket - the socket that will get added\n   * @param fn - last fn call in the middleware\n   * @private\n   */\n\n\n  run(socket, fn) {\n    const fns = this._fns.slice(0);\n\n    if (!fns.length) return fn(null);\n\n    function run(i) {\n      fns[i](socket, function (err) {\n        // upon error, short-circuit\n        if (err) return fn(err); // if no middleware left, summon callback\n\n        if (!fns[i + 1]) return fn(null); // go on to next\n\n        run(i + 1);\n      });\n    }\n\n    run(0);\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param name\n   * @return self\n   * @public\n   */\n\n\n  to(name) {\n    this._rooms.add(name);\n\n    return this;\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param name\n   * @return self\n   * @public\n   */\n\n\n  in(name) {\n    this._rooms.add(name);\n\n    return this;\n  }\n  /**\n   * Adds a new client.\n   *\n   * @return {Socket}\n   * @private\n   */\n\n\n  _add(client, query, fn) {\n    debug(\"adding socket to nsp %s\", this.name);\n    const socket = new socket_1.Socket(this, client, query);\n    this.run(socket, err => {\n      process.nextTick(() => {\n        if (\"open\" == client.conn.readyState) {\n          if (err) return socket._error({\n            message: err.message,\n            data: err.data\n          }); // track socket\n\n          this.sockets.set(socket.id, socket); // it's paramount that the internal `onconnect` logic\n          // fires before user-set events to prevent state order\n          // violations (such as a disconnection before the connection\n          // logic is complete)\n\n          socket._onconnect();\n\n          if (fn) fn(); // fire user-set events\n\n          super.emit(\"connect\", socket);\n          super.emit(\"connection\", socket);\n        } else {\n          debug(\"next called after client was closed - ignoring socket\");\n        }\n      });\n    });\n    return socket;\n  }\n  /**\n   * Removes a client. Called by each `Socket`.\n   *\n   * @private\n   */\n\n\n  _remove(socket) {\n    if (this.sockets.has(socket.id)) {\n      this.sockets.delete(socket.id);\n    } else {\n      debug(\"ignoring remove for %s\", socket.id);\n    }\n  }\n  /**\n   * Emits to all clients.\n   *\n   * @return Always true\n   * @public\n   */\n\n\n  emit(ev, ...args) {\n    if (socket_1.RESERVED_EVENTS.has(ev)) {\n      throw new Error(`\"${ev}\" is a reserved event name`);\n    } // set up packet object\n\n\n    args.unshift(ev);\n    const packet = {\n      type: socket_io_parser_1.PacketType.EVENT,\n      data: args\n    };\n\n    if (\"function\" == typeof args[args.length - 1]) {\n      throw new Error(\"Callbacks are not supported when broadcasting\");\n    }\n\n    const rooms = new Set(this._rooms);\n    const flags = Object.assign({}, this._flags); // reset flags\n\n    this._rooms.clear();\n\n    this._flags = {};\n    this.adapter.broadcast(packet, {\n      rooms: rooms,\n      flags: flags\n    });\n    return true;\n  }\n  /**\n   * Sends a `message` event to all clients.\n   *\n   * @return self\n   * @public\n   */\n\n\n  send(...args) {\n    this.emit(\"message\", ...args);\n    return this;\n  }\n  /**\n   * Sends a `message` event to all clients.\n   *\n   * @return self\n   * @public\n   */\n\n\n  write(...args) {\n    this.emit(\"message\", ...args);\n    return this;\n  }\n  /**\n   * Gets a list of clients.\n   *\n   * @return self\n   * @public\n   */\n\n\n  allSockets() {\n    if (!this.adapter) {\n      throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n    }\n\n    const rooms = new Set(this._rooms);\n\n    this._rooms.clear();\n\n    return this.adapter.sockets(rooms);\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @param compress - if `true`, compresses the sending data\n   * @return self\n   * @public\n   */\n\n\n  compress(compress) {\n    this._flags.compress = compress;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n   * receive messages (because of network slowness or other issues, or because theyâ€™re connected through long polling\n   * and is in the middle of a request-response cycle).\n   *\n   * @return self\n   * @public\n   */\n\n\n  get volatile() {\n    this._flags.volatile = true;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n   *\n   * @return self\n   * @public\n   */\n\n\n  get local() {\n    this._flags.local = true;\n    return this;\n  }\n\n}\n\nexports.Namespace = Namespace;","map":{"version":3,"sources":["/Users/paulinez/connect-four/node_modules/socket.io/dist/namespace.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Namespace","socket_1","require","events_1","socket_io_parser_1","debug_1","debug","default","EventEmitter","constructor","server","name","sockets","Map","_fns","_rooms","Set","_flags","_ids","_initAdapter","adapter","use","fn","push","run","socket","fns","slice","length","i","err","to","add","in","_add","client","query","Socket","process","nextTick","conn","readyState","_error","message","data","set","id","_onconnect","emit","_remove","has","delete","ev","args","RESERVED_EVENTS","Error","unshift","packet","type","PacketType","EVENT","rooms","flags","assign","clear","broadcast","send","write","allSockets","compress","volatile","local"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Namespace = void 0;\nconst socket_1 = require(\"./socket\");\nconst events_1 = require(\"events\");\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"socket.io:namespace\");\nclass Namespace extends events_1.EventEmitter {\n    /**\n     * Namespace constructor.\n     *\n     * @param server instance\n     * @param name\n     */\n    constructor(server, name) {\n        super();\n        this.sockets = new Map();\n        /** @private */\n        this._fns = [];\n        /** @private */\n        this._rooms = new Set();\n        /** @private */\n        this._flags = {};\n        /** @private */\n        this._ids = 0;\n        this.server = server;\n        this.name = name;\n        this._initAdapter();\n    }\n    /**\n     * Initializes the `Adapter` for this nsp.\n     * Run upon changing adapter by `Server#adapter`\n     * in addition to the constructor.\n     *\n     * @private\n     */\n    _initAdapter() {\n        this.adapter = new (this.server.adapter())(this);\n    }\n    /**\n     * Sets up namespace middleware.\n     *\n     * @return self\n     * @public\n     */\n    use(fn) {\n        this._fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming client.\n     *\n     * @param socket - the socket that will get added\n     * @param fn - last fn call in the middleware\n     * @private\n     */\n    run(socket, fn) {\n        const fns = this._fns.slice(0);\n        if (!fns.length)\n            return fn(null);\n        function run(i) {\n            fns[i](socket, function (err) {\n                // upon error, short-circuit\n                if (err)\n                    return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1])\n                    return fn(null);\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param name\n     * @return self\n     * @public\n     */\n    to(name) {\n        this._rooms.add(name);\n        return this;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param name\n     * @return self\n     * @public\n     */\n    in(name) {\n        this._rooms.add(name);\n        return this;\n    }\n    /**\n     * Adds a new client.\n     *\n     * @return {Socket}\n     * @private\n     */\n    _add(client, query, fn) {\n        debug(\"adding socket to nsp %s\", this.name);\n        const socket = new socket_1.Socket(this, client, query);\n        this.run(socket, (err) => {\n            process.nextTick(() => {\n                if (\"open\" == client.conn.readyState) {\n                    if (err)\n                        return socket._error({\n                            message: err.message,\n                            data: err.data,\n                        });\n                    // track socket\n                    this.sockets.set(socket.id, socket);\n                    // it's paramount that the internal `onconnect` logic\n                    // fires before user-set events to prevent state order\n                    // violations (such as a disconnection before the connection\n                    // logic is complete)\n                    socket._onconnect();\n                    if (fn)\n                        fn();\n                    // fire user-set events\n                    super.emit(\"connect\", socket);\n                    super.emit(\"connection\", socket);\n                }\n                else {\n                    debug(\"next called after client was closed - ignoring socket\");\n                }\n            });\n        });\n        return socket;\n    }\n    /**\n     * Removes a client. Called by each `Socket`.\n     *\n     * @private\n     */\n    _remove(socket) {\n        if (this.sockets.has(socket.id)) {\n            this.sockets.delete(socket.id);\n        }\n        else {\n            debug(\"ignoring remove for %s\", socket.id);\n        }\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @return Always true\n     * @public\n     */\n    emit(ev, ...args) {\n        if (socket_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${ev}\" is a reserved event name`);\n        }\n        // set up packet object\n        args.unshift(ev);\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: args,\n        };\n        if (\"function\" == typeof args[args.length - 1]) {\n            throw new Error(\"Callbacks are not supported when broadcasting\");\n        }\n        const rooms = new Set(this._rooms);\n        const flags = Object.assign({}, this._flags);\n        // reset flags\n        this._rooms.clear();\n        this._flags = {};\n        this.adapter.broadcast(packet, {\n            rooms: rooms,\n            flags: flags,\n        });\n        return true;\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * @return self\n     * @public\n     */\n    send(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * @return self\n     * @public\n     */\n    write(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @return self\n     * @public\n     */\n    allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        const rooms = new Set(this._rooms);\n        this._rooms.clear();\n        return this.adapter.sockets(rooms);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     * @public\n     */\n    compress(compress) {\n        this._flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyâ€™re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @return self\n     * @public\n     */\n    get volatile() {\n        this._flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @return self\n     * @public\n     */\n    get local() {\n        this._flags.local = true;\n        return this;\n    }\n}\nexports.Namespace = Namespace;\n"]},"metadata":{},"sourceType":"script"}