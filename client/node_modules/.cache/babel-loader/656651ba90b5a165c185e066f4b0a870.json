{"ast":null,"code":"export function createGrid(rows, columns) {\n  let grid = [];\n  let i = 0;\n\n  while (i < rows) {\n    grid.push(Array(columns).fill(null));\n    i++;\n  }\n\n  grid.push(Array(columns).fill(\"base\"));\n  return grid;\n}\nexport function checkResult(grid) {\n  if (!grid) return;\n\n  for (let x in grid) {\n    x = parseInt(x);\n\n    for (let y in grid[x]) {\n      y = parseInt(y);\n      let value = grid[x][y];\n      if (value === \"base\") continue;\n\n      if ( //left and right\n      value && value === grid[x][y + 1] && value === grid[x][y + 2] && value === grid[x][y + 3] || //up and down\n      value && value === grid[x + 1][y] && value === grid[x + 2][y] && value === grid[x + 3][y] || //diagonal - left to right (\\)\n      value && value === grid[x + 1][y + 1] && value === grid[x + 2][y + 2] && value === grid[x + 3][y + 3] || //diagonal - right to left (/)\n      value && value === grid[x + 1][y - 1] && value === grid[x + 2][y - 2] && value === grid[x + 3][y - 3]) {\n        return value + \" wins\";\n      }\n\n      const tie = grid.every(row => !row.includes(null));\n      if (tie) return \"Draw!\";\n    }\n  }\n}\nexport function findAValidMove(grid, player, rowIndex, columnIndex) {\n  let r = rowIndex;\n  let c = columnIndex;\n\n  if (grid[r][c] === \"base\") {\n    return null;\n  }\n\n  if (grid[r + 1][c] !== null && grid[r][c] === null) {\n    // const copyGrid = grid.slice();\n    // copyGrid[r][c] = player;\n    // return copyGrid;\n    grid[r][c] = player;\n    return grid;\n  }\n\n  return null;\n}\nexport function findAiMove(grid, huPlayer, aiPlayer) {\n  let bestMoveScore = 100;\n  let move = [];\n\n  for (let rowIndex in grid) {\n    console.log(\"checking new row\");\n    rowIndex = parseInt(rowIndex);\n\n    for (let columnIndex in grid[rowIndex]) {\n      columnIndex = parseInt(columnIndex);\n      const newGrid = findAValidMove(grid, aiPlayer, rowIndex, columnIndex);\n\n      if (newGrid) {\n        const moveScore = maxScore(newGrid, huPlayer, aiPlayer); // newGrid[rowIndex][columnIndex] = null;\n\n        if (moveScore < bestMoveScore) {\n          bestMoveScore = moveScore;\n          move = [rowIndex, columnIndex];\n        }\n      }\n    }\n  }\n\n  console.log({\n    move\n  });\n  return move;\n\n  function minScore(grid, huPlayer, aiPlayer) {\n    let result = checkResult(grid);\n\n    if (result === \"Player-1 wins\") {\n      // console.log(\"min checked1\");\n      return 10;\n    }\n\n    if (result === \"Player-2 wins\") {\n      // console.log(\"min checked2\");\n      return -10;\n    }\n\n    if (result === \"Draw\") {\n      // console.log(\"min checked3\");\n      return 0;\n    }\n\n    let bestMoveScore = 100;\n\n    for (let rowIndex in grid) {\n      rowIndex = parseInt(rowIndex);\n\n      for (let columnIndex in grid[rowIndex]) {\n        columnIndex = parseInt(columnIndex);\n        const newGrid3 = findAValidMove(grid, aiPlayer, rowIndex, columnIndex);\n\n        if (newGrid3) {\n          const moveScore = maxScore(newGrid3, huPlayer, aiPlayer);\n          newGrid3[rowIndex][columnIndex] = null;\n\n          if (moveScore < bestMoveScore) {\n            bestMoveScore = moveScore;\n          }\n        }\n      }\n    }\n\n    return bestMoveScore;\n  }\n\n  function maxScore(grid, huPlayer, aiPlayer) {\n    let result = checkResult(grid);\n\n    if (result === \"Player-1 wins\") {\n      // console.log(\"max checked\");\n      return 10;\n    }\n\n    if (result === \"Player-2 wins\") {\n      // console.log(\"max checked\");\n      return -10;\n    }\n\n    if (result === \"Draw\") {\n      // console.log(\"max checked\");\n      return 0;\n    }\n\n    let bestMoveScore = -100;\n\n    for (let rowIndex in grid) {\n      rowIndex = parseInt(rowIndex);\n\n      for (let columnIndex in grid[rowIndex]) {\n        columnIndex = parseInt(columnIndex);\n        const newGrid2 = findAValidMove(grid, huPlayer, rowIndex, columnIndex);\n\n        if (newGrid2) {\n          const moveScore = minScore(newGrid2, huPlayer, aiPlayer);\n          newGrid2[rowIndex][columnIndex] = null;\n          console.log({\n            moveScore\n          });\n\n          if (moveScore > bestMoveScore) {\n            bestMoveScore = moveScore;\n            console.log({\n              bestMoveScore\n            });\n          }\n        }\n      }\n    }\n\n    return bestMoveScore;\n  }\n}","map":{"version":3,"sources":["/Users/paulinez/connect-four/client/src/components/Game/help.js"],"names":["createGrid","rows","columns","grid","i","push","Array","fill","checkResult","x","parseInt","y","value","tie","every","row","includes","findAValidMove","player","rowIndex","columnIndex","r","c","findAiMove","huPlayer","aiPlayer","bestMoveScore","move","console","log","newGrid","moveScore","maxScore","minScore","result","newGrid3","newGrid2"],"mappings":"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","sourcesContent":["export function createGrid(rows, columns) {\n  let grid = [];\n  let i = 0;\n  while (i < rows) {\n    grid.push(Array(columns).fill(null));\n    i++;\n  }\n  grid.push(Array(columns).fill(\"base\"));\n  return grid;\n}\n\nexport function checkResult(grid) {\n  if (!grid) return;\n\n  for (let x in grid) {\n    x = parseInt(x);\n    for (let y in grid[x]) {\n      y = parseInt(y);\n      let value = grid[x][y];\n\n      if (value === \"base\") continue;\n      if (\n        //left and right\n        (value &&\n          value === grid[x][y + 1] &&\n          value === grid[x][y + 2] &&\n          value === grid[x][y + 3]) ||\n        //up and down\n        (value &&\n          value === grid[x + 1][y] &&\n          value === grid[x + 2][y] &&\n          value === grid[x + 3][y]) ||\n        //diagonal - left to right (\\)\n        (value &&\n          value === grid[x + 1][y + 1] &&\n          value === grid[x + 2][y + 2] &&\n          value === grid[x + 3][y + 3]) ||\n        //diagonal - right to left (/)\n        (value &&\n          value === grid[x + 1][y - 1] &&\n          value === grid[x + 2][y - 2] &&\n          value === grid[x + 3][y - 3])\n      ) {\n        return value + \" wins\";\n      }\n      const tie = grid.every((row) => !row.includes(null));\n      if (tie) return \"Draw!\";\n    }\n  }\n}\n\nexport function findAValidMove(grid, player, rowIndex, columnIndex) {\n  let r = rowIndex;\n  let c = columnIndex;\n  if (grid[r][c] === \"base\") {\n    return null;\n  }\n  if (grid[r + 1][c] !== null && grid[r][c] === null) {\n    // const copyGrid = grid.slice();\n    // copyGrid[r][c] = player;\n    // return copyGrid;\n\n    grid[r][c] = player;\n    return grid;\n  }\n  return null;\n}\n\nexport function findAiMove(grid, huPlayer, aiPlayer) {\n  let bestMoveScore = 100;\n  let move = [];\n\n  for (let rowIndex in grid) {\n    console.log(\"checking new row\");\n    rowIndex = parseInt(rowIndex);\n    for (let columnIndex in grid[rowIndex]) {\n      columnIndex = parseInt(columnIndex);\n      const newGrid = findAValidMove(grid, aiPlayer, rowIndex, columnIndex);\n      if (newGrid) {\n        const moveScore = maxScore(newGrid, huPlayer, aiPlayer);\n        // newGrid[rowIndex][columnIndex] = null;\n        if (moveScore < bestMoveScore) {\n          bestMoveScore = moveScore;\n          move = [rowIndex, columnIndex];\n        }\n      }\n    }\n  }\n  console.log({ move });\n  return move;\n\n  function minScore(grid, huPlayer, aiPlayer) {\n    let result = checkResult(grid);\n    if (result === \"Player-1 wins\") {\n      // console.log(\"min checked1\");\n      return 10;\n    }\n    if (result === \"Player-2 wins\") {\n      // console.log(\"min checked2\");\n      return -10;\n    }\n    if (result === \"Draw\") {\n      // console.log(\"min checked3\");\n      return 0;\n    }\n\n    let bestMoveScore = 100;\n    for (let rowIndex in grid) {\n      rowIndex = parseInt(rowIndex);\n      for (let columnIndex in grid[rowIndex]) {\n        columnIndex = parseInt(columnIndex);\n        const newGrid3 = findAValidMove(grid, aiPlayer, rowIndex, columnIndex);\n        if (newGrid3) {\n          const moveScore = maxScore(newGrid3, huPlayer, aiPlayer);\n          newGrid3[rowIndex][columnIndex] = null;\n          if (moveScore < bestMoveScore) {\n            bestMoveScore = moveScore;\n          }\n        }\n      }\n    }\n    return bestMoveScore;\n  }\n\n  function maxScore(grid, huPlayer, aiPlayer) {\n    let result = checkResult(grid);\n    if (result === \"Player-1 wins\") {\n      // console.log(\"max checked\");\n      return 10;\n    }\n    if (result === \"Player-2 wins\") {\n      // console.log(\"max checked\");\n      return -10;\n    }\n    if (result === \"Draw\") {\n      // console.log(\"max checked\");\n      return 0;\n    }\n    let bestMoveScore = -100;\n    for (let rowIndex in grid) {\n      rowIndex = parseInt(rowIndex);\n      for (let columnIndex in grid[rowIndex]) {\n        columnIndex = parseInt(columnIndex);\n        const newGrid2 = findAValidMove(grid, huPlayer, rowIndex, columnIndex);\n        if (newGrid2) {\n          const moveScore = minScore(newGrid2, huPlayer, aiPlayer);\n          newGrid2[rowIndex][columnIndex] = null;\n          console.log({ moveScore });\n          if (moveScore > bestMoveScore) {\n            bestMoveScore = moveScore;\n            console.log({ bestMoveScore });\n          }\n        }\n      }\n    }\n    return bestMoveScore;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}