{"ast":null,"code":"// NOTE\n// r = row index\n// c = column index\nexport function createGrid(r, c) {\n  let grid = [];\n  let i = 0;\n\n  while (i < r) {\n    grid.push(Array(c).fill(null));\n    i++;\n  }\n\n  return grid;\n}\nexport function checkResult(grid) {\n  const tie = grid.every(row => !row.includes(null));\n  if (tie) return \"Draw!\";\n\n  for (let r = 0; r < grid.length; r++) {\n    for (let c = 0; c < grid[r].length; c++) {\n      let value = grid[r][c];\n\n      if ( //left and right\n      value && value === grid[r][c + 1] && value === grid[r][c + 2] && value === grid[r][c + 3]) {\n        return value + \" wins\";\n      }\n\n      if (r < grid.length - 3) {\n        if ( //up and down\n        value && value === grid[r + 1][c] && value === grid[r + 2][c] && value === grid[r + 3][c] || //diagonal \" \\ \"\n        value && value === grid[r + 1][c + 1] && value === grid[r + 2][c + 2] && value === grid[r + 3][c + 3] || //diagonal \" / \"\n        value && value === grid[r + 1][c - 1] && value === grid[r + 2][c - 2] && value === grid[r + 3][c - 3]) {\n          return value + \" wins\";\n        }\n      }\n    }\n  }\n\n  return null;\n}\nexport function findAValidMove(grid, c) {\n  for (let r = grid.length - 1; r >= 0; r--) {\n    if (grid[r][c] === null) {\n      let move = [r, c];\n      return move;\n    }\n  }\n}\nexport function findAiMove(grid, columns, huPlayer, aiPlayer) {\n  let MAX_DEPTH = 3;\n  let bestMoveScore = 100;\n  let move = [];\n  let columnIndexes = columns - 1;\n\n  for (let c = columnIndexes; c >= 0; c--) {\n    let newMove = findAValidMove(grid, c);\n\n    if (newMove) {\n      const [row, col] = newMove;\n      grid[row][col] = aiPlayer;\n      const moveScore = maxScore(grid, columnIndexes, MAX_DEPTH, huPlayer, aiPlayer);\n      grid[row][col] = null;\n\n      if (moveScore < bestMoveScore) {\n        bestMoveScore = moveScore;\n        move = [row, col];\n      }\n    }\n  }\n\n  console.log({\n    move\n  });\n  return move;\n}\n\nfunction minScore(grid, columnIndexes, depth, huPlayer, aiPlayer) {\n  let result = checkResult(grid);\n\n  if (result) {\n    console.log(\"result\");\n    if (result === \"Player-1 wins\") return 10;\n    if (result === \"Player-2 wins\") return -10;\n    if (result === \"Draw\") return 0;\n  }\n\n  if (depth === 0) return 0;\n  let bestMoveScore = 100;\n\n  for (let c = columnIndexes; c >= 0; c--) {\n    const newMove = findAValidMove(grid, c);\n\n    if (newMove) {\n      const [row, col] = newMove;\n      grid[row][col] = huPlayer;\n      const moveScore = maxScore(grid, columnIndexes, depth - 1, huPlayer, aiPlayer);\n      grid[row][col] = null;\n\n      if (moveScore < bestMoveScore) {\n        bestMoveScore = moveScore;\n      }\n    }\n  }\n\n  return bestMoveScore;\n}\n\nfunction maxScore(grid, columnIndexes, depth, huPlayer, aiPlayer) {\n  let result = checkResult(grid);\n\n  if (result) {\n    console.log(\"result\");\n    if (result === \"Player-1 wins\") return 10;\n    if (result === \"Player-2 wins\") return -10;\n    if (result === \"Draw\") return 0;\n  }\n\n  if (depth === 0) return 0;\n  let bestMoveScore = -100;\n\n  for (let c = columnIndexes; c >= 0; c--) {\n    let newMove = findAValidMove(grid, c);\n\n    if (newMove) {\n      const [row, col] = newMove;\n      grid[row][col] = huPlayer;\n      const moveScore = minScore(grid, columnIndexes, depth - 1, huPlayer, aiPlayer);\n      grid[row][col] = null;\n\n      if (moveScore > bestMoveScore) {\n        bestMoveScore = moveScore;\n      }\n    }\n  }\n\n  return bestMoveScore;\n}","map":{"version":3,"sources":["/Users/paulinez/connect-four/client/src/components/Game/help.js"],"names":["createGrid","r","c","grid","i","push","Array","fill","checkResult","tie","every","row","includes","length","value","findAValidMove","move","findAiMove","columns","huPlayer","aiPlayer","MAX_DEPTH","bestMoveScore","columnIndexes","newMove","col","moveScore","maxScore","console","log","minScore","depth","result"],"mappings":"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","sourcesContent":["// NOTE\n// r = row index\n// c = column index\n\nexport function createGrid(r, c) {\n  let grid = [];\n  let i = 0;\n  while (i < r) {\n    grid.push(Array(c).fill(null));\n    i++;\n  }\n  return grid;\n}\n\nexport function checkResult(grid) {\n  const tie = grid.every((row) => !row.includes(null));\n  if (tie) return \"Draw!\";\n\n  for (let r = 0; r < grid.length; r++) {\n    for (let c = 0; c < grid[r].length; c++) {\n      let value = grid[r][c];\n\n      if (\n        //left and right\n        value &&\n        value === grid[r][c + 1] &&\n        value === grid[r][c + 2] &&\n        value === grid[r][c + 3]\n      ) {\n        return value + \" wins\";\n      }\n\n      if (r < grid.length - 3) {\n        if (\n          //up and down\n          (value &&\n            value === grid[r + 1][c] &&\n            value === grid[r + 2][c] &&\n            value === grid[r + 3][c]) ||\n          //diagonal \" \\ \"\n          (value &&\n            value === grid[r + 1][c + 1] &&\n            value === grid[r + 2][c + 2] &&\n            value === grid[r + 3][c + 3]) ||\n          //diagonal \" / \"\n          (value &&\n            value === grid[r + 1][c - 1] &&\n            value === grid[r + 2][c - 2] &&\n            value === grid[r + 3][c - 3])\n        ) {\n          return value + \" wins\";\n        }\n      }\n    }\n  }\n  return null;\n}\n\nexport function findAValidMove(grid, c) {\n  for (let r = grid.length - 1; r >= 0; r--) {\n    if (grid[r][c] === null) {\n      let move = [r, c];\n      return move;\n    }\n  }\n}\n\nexport function findAiMove(grid, columns, huPlayer, aiPlayer) {\n  let MAX_DEPTH = 3;\n  let bestMoveScore = 100;\n  let move = [];\n  let columnIndexes = columns - 1;\n\n  for (let c = columnIndexes; c >= 0; c--) {\n    let newMove = findAValidMove(grid, c);\n    if (newMove) {\n      const [row, col] = newMove;\n      grid[row][col] = aiPlayer;\n      const moveScore = maxScore(\n        grid,\n        columnIndexes,\n        MAX_DEPTH,\n        huPlayer,\n        aiPlayer\n      );\n      grid[row][col] = null;\n      if (moveScore < bestMoveScore) {\n        bestMoveScore = moveScore;\n        move = [row, col];\n      }\n    }\n  }\n\n  console.log({ move });\n\n  return move;\n}\n\nfunction minScore(grid, columnIndexes, depth, huPlayer, aiPlayer) {\n  let result = checkResult(grid);\n  if (result) {\n    console.log(\"result\");\n    if (result === \"Player-1 wins\") return 10;\n    if (result === \"Player-2 wins\") return -10;\n    if (result === \"Draw\") return 0;\n  }\n  if (depth === 0) return 0;\n\n  let bestMoveScore = 100;\n  for (let c = columnIndexes; c >= 0; c--) {\n    const newMove = findAValidMove(grid, c);\n    if (newMove) {\n      const [row, col] = newMove;\n      grid[row][col] = huPlayer;\n      const moveScore = maxScore(\n        grid,\n        columnIndexes,\n        depth - 1,\n        huPlayer,\n        aiPlayer\n      );\n      grid[row][col] = null;\n      if (moveScore < bestMoveScore) {\n        bestMoveScore = moveScore;\n      }\n    }\n  }\n\n  return bestMoveScore;\n}\n\nfunction maxScore(grid, columnIndexes, depth, huPlayer, aiPlayer) {\n  let result = checkResult(grid);\n  if (result) {\n    console.log(\"result\");\n    if (result === \"Player-1 wins\") return 10;\n    if (result === \"Player-2 wins\") return -10;\n    if (result === \"Draw\") return 0;\n  }\n  if (depth === 0) return 0;\n\n  let bestMoveScore = -100;\n  for (let c = columnIndexes; c >= 0; c--) {\n    let newMove = findAValidMove(grid, c);\n    if (newMove) {\n      const [row, col] = newMove;\n      grid[row][col] = huPlayer;\n      const moveScore = minScore(\n        grid,\n        columnIndexes,\n        depth - 1,\n        huPlayer,\n        aiPlayer\n      );\n      grid[row][col] = null;\n      if (moveScore > bestMoveScore) {\n        bestMoveScore = moveScore;\n      }\n    }\n  }\n\n  return bestMoveScore;\n}\n"]},"metadata":{},"sourceType":"module"}